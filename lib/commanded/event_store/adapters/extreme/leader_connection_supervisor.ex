defmodule Commanded.EventStore.Adapters.Extreme.LeaderConnectionSupervisor do
  @moduledoc """
  The LeaderConnectionSupervisor is a dynamic supervisor that keeps a single
  child Spear.Connection with a dynamic config.

  The leader connection should always be connected to the leader node in a cluster
  and is accessible via name generated by `Config.leader_conn_name/1`

  The main way of interacting with the LeaderConnectionSupervisor is through
  LeaderConnectionManager.
  """

  use DynamicSupervisor

  require Logger

  alias Commanded.EventStore.Adapters.Extreme.Config

  def start_link(config) do
    Logger.debug("LeaderConnectionSupervisor (#{inspect(self())}) start_link")

    # We use a DynamicSupervisor with a single child, as that process may
    # require being replaced with a new one using updated configuration. Using
    # a DynamicSupervisor makes achieving this easier than a standard Supervisor,
    # where the child_spec would have to be deleted after each process
    # termination, in order to start the child process with a modified child
    # spec configuration.
    name = Keyword.fetch!(config, :adapter_name) |> Config.leader_conn_supervisor_name()
    DynamicSupervisor.start_link(__MODULE__, config, name: name)
  end

  @impl true
  @spec init(any) ::
          {:ok,
           %{
             extra_arguments: list,
             intensity: non_neg_integer,
             max_children: :infinity | non_neg_integer,
             period: pos_integer,
             strategy: :one_for_one
           }}
  def init(_config) do
    Logger.debug("LeaderConnectionSupervisor (#{inspect(self())}) init")

    DynamicSupervisor.init(strategy: :one_for_one)
  end

  def start_leader_connection(leader_conn_supervisor_name, conn_config) do
    Logger.debug(
      "LeaderConnectionSupervisor (#{inspect(self())}) start_leader_connection #{inspect(conn_config)}"
    )

    case DynamicSupervisor.start_child(
           leader_conn_supervisor_name,
           {Spear.Connection, conn_config}
         ) do
      {:ok, pid} ->
        {:ok, pid}

      {:ok, pid, _info} ->
        {:ok, pid}

      {:error, {:already_started, pid}} ->
        {:ok, pid}

      errors ->
        errors
    end
  end

  def refresh_leader_connection(leader_conn_supervisor_name, conn_config, leader_conn_pid) do
    Logger.debug(
      "LeaderConnectionSupervisor (#{inspect(self())}) refresh_leader_connection #{inspect(conn_config)}"
    )

    DynamicSupervisor.terminate_child(leader_conn_supervisor_name, leader_conn_pid)

    start_leader_connection(leader_conn_supervisor_name, conn_config)
  end
end
